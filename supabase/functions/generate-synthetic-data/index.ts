
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.7";

const SUPABASE_URL = Deno.env.get('SUPABASE_URL') || "";
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || "";
const OPENAI_API_KEY = Deno.env.get('OPENAI_API_KEY');

// Set up CORS headers
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Initialize Supabase client with service role key for database access
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { tableName, count = 50 } = await req.json();
    
    if (!tableName) {
      return new Response(
        JSON.stringify({ error: "Table name is required" }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }
    
    // Get table schema
    const { data: tableInfo, error: tableError } = await supabase
      .rpc('execute_sql_query', { 
        sql_query: `
          SELECT column_name, data_type, is_nullable 
          FROM information_schema.columns 
          WHERE table_name = '${tableName}'
          AND table_schema = 'public'
        `
      });
    
    if (tableError) {
      throw new Error(`Error fetching table schema: ${tableError.message}`);
    }
    
    if (!tableInfo || tableInfo.length === 0) {
      return new Response(
        JSON.stringify({ error: `Table '${tableName}' not found or has no columns` }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }
    
    // Create OpenAI prompt for synthetic data generation
    const prompt = `
    Generate synthetic data for a PostgreSQL table with these columns:
    ${tableInfo.map(col => `${col.column_name} (${col.data_type}, ${col.is_nullable === 'YES' ? 'nullable' : 'not nullable'})`).join('\n')}
    
    The data should be realistic for an innovation agency database. Please generate exactly ${count} rows.
    Return the data as a JSON array with objects where the keys are the column names.
    For UUID columns, use the string "NEW_UUID" which I will replace with generated UUIDs.
    For date or timestamp columns, use ISO format strings.
    The data should be varied, diverse, and realistic.
    
    For specific columns:
    - If there's a 'name' column, use realistic names related to innovation programs, metrics, or organizations.
    - If there's a 'sector' column, use sectors like 'Technology', 'Healthcare', 'Energy', 'Agriculture', etc.
    - If there's a 'region' column, use Portuguese regions like 'Norte', 'Centro', 'Lisboa', 'Alentejo', 'Algarve', etc.
    - If there's a 'status' column, use appropriate statuses like 'active', 'pending', 'completed', 'rejected', etc.
    
    Only return the JSON array, no explanation.
    `;
    
    // Call OpenAI API to generate synthetic data
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${OPENAI_API_KEY}`
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [
          { role: 'system', content: 'You are a database seeding expert that generates realistic synthetic data in JSON format.' },
          { role: 'user', content: prompt }
        ],
        temperature: 0.7,
        max_tokens: 2000
      })
    });
    
    if (!response.ok) {
      const errorData = await response.text();
      throw new Error(`OpenAI API error: ${errorData}`);
    }
    
    const data = await response.json();
    let syntheticDataStr = data.choices[0].message.content.trim();
    
    // Extract the JSON array from the response
    let syntheticData;
    try {
      // Handle cases where the response includes markdown code blocks
      if (syntheticDataStr.includes('```')) {
        syntheticDataStr = syntheticDataStr.replace(/```json\n|\n```|```/g, '');
      }
      syntheticData = JSON.parse(syntheticDataStr);
    } catch (e) {
      console.error('Error parsing synthetic data JSON:', e);
      throw new Error('Failed to parse the generated synthetic data');
    }
    
    // Process the synthetic data
    const processedData = syntheticData.map((item: any) => {
      const processed: any = {};
      
      // Process each column
      for (const col of tableInfo) {
        const colName = col.column_name;
        let value = item[colName];
        
        // Skip id column if it's a UUID type (will be generated by the database)
        if (colName === 'id' && col.data_type.includes('uuid')) {
          continue;
        }
        
        // Replace 'NEW_UUID' with null for UUID columns (database will generate them)
        if (col.data_type.includes('uuid') && value === 'NEW_UUID') {
          value = null;
        }
        
        // Remove timestamp columns if they will be set by defaults
        if ((colName === 'created_at' || colName === 'updated_at') && 
            col.data_type.includes('timestamp')) {
          continue;
        }
        
        // Include the processed value
        processed[colName] = value;
      }
      
      return processed;
    });
    
    // Clear existing data from the table
    const { error: clearError } = await supabase
      .from(tableName)
      .delete()
      .neq('id', '00000000-0000-0000-0000-000000000000'); // Delete all rows
    
    if (clearError) {
      throw new Error(`Error clearing table data: ${clearError.message}`);
    }
    
    // Insert synthetic data in batches
    const batchSize = 20;
    const results = [];
    
    for (let i = 0; i < processedData.length; i += batchSize) {
      const batch = processedData.slice(i, i + batchSize);
      
      const { data: insertData, error: insertError } = await supabase
        .from(tableName)
        .insert(batch)
        .select();
      
      if (insertError) {
        throw new Error(`Error inserting batch ${i/batchSize + 1}: ${insertError.message}`);
      }
      
      results.push(insertData);
    }
    
    return new Response(
      JSON.stringify({ 
        message: `Successfully generated and inserted ${processedData.length} synthetic records into ${tableName}` 
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('Error generating synthetic data:', error);
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
